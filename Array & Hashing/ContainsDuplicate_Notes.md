# 学習ノート: Contains Duplicate (NeetCode)

## 1. 問題概要

整数の配列 `nums` が与えられたとき、いずれかの値が2回以上現れる場合は `true` を、そうでなければ `false` を返す。

## 2. 検討した解法

### 解法1: ブルートフォース（総当たり）

- **アプローチ:** 二重ループを使い、配列の各要素を他のすべての要素と比較する。
- **計算量:**
  - 時間計算量: O(n^2)
  - 空間計算量: O(1)
- **評価:** 最も直感的だが、配列が大きくなると非常に遅くなる。

### 解法2: ソート

- **アプローチ:**
  1. 配列をソートする。
  2. 隣り合う要素を比較し、同じものがあれば重複とみなす。
- **計算量:**
  - 時間計算量: O(n log n) （ソートにかかる時間）
  - 空間計算量: O(1) or O(n) （ソートの実装による）
- **評価:** ブルートフォースより大幅に効率的。

### 解法3: ハッシュセット

- **アプローチ:**
  1. 空のハッシュセット（`std::unordered_set`）を用意する。
  2. 配列の要素を順番に見ていく。
  3. もし要素が既にセットに存在すれば、重複なので `true` を返す。
  4. 存在しなければ、その要素をセットに追加する。
  5. 最後までループが終われば、重複はなかったので `false` を返す。
- **計算量:**
  - 時間計算量: O(n) （各要素のセットへのアクセスが平均O(1)のため）
  - 空間計算量: O(k) （kはユニークな要素の数）
- **評価:** 最も時間効率の良い解法。ただし、追加のメモリが必要。

## 3. feat: 今回の学び

### ハッシュテーブルの威力

- `std::unordered_set` や `std::unordered_map` がなぜ高速なのかを学んだ。
- **ハッシュ関数**という仕組みを使い、値から格納場所のインデックスを直接計算することで、検索・追加・削除を平均**O(1)**で行える。
- これにより、線形探索（O(n)）が必要な処理を劇的に高速化できる。

### `unordered_set` vs `unordered_map`

- **本質は同じ:** どちらも内部でハッシュテーブルを利用している。
- **目的が違う:**
  - `unordered_set`: **存在の有無**だけを管理したい場合に使う。（例: 「この数字は見たことがあるか？」）
  - `unordered_map`: **キーと値のペア**を管理したい場合に使う。（例: 「この単語は何回出現したか？」）
- **使い分け:** 問題の要求に応じて、よりシンプルで適切なデータ構造を選択することが重要。今回の問題では、存在チェックだけで十分なため `unordered_set` が最適だった。
